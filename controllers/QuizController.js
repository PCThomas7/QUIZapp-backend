import Quiz from '../models/Quiz.js';
import QuizAttempt from '../models/QuizAttempt.js';
import { v4 as uuidv4 } from 'uuid'; // Add this import at the top
import QuestionBank from '../models/QuestionBank.js';
import {QuizBatch,Batch} from '../db/db.js'
import mongoose from 'mongoose';

// Update the createQuiz and updateQuiz methods to handle scheduling data

const createQuiz = async (req, res) => {
    try {
        const { 
            title,
            description,
            total_duration,
            timeLimit,
            header,
            instructions,
            footer,
            watermark,
            sections,
            createdBy,
            batchAssignment,
            assignedBatches,
            // Add scheduling fields
            isScheduled,
            startDate,
            endDate
        } = req.body;

        // Create new quiz with unique ID
        const newQuiz = new Quiz({
            id: uuidv4(),
            title,
            description,
            timeLimit: timeLimit || total_duration || 0,
            createdBy,
            batchAssignment: batchAssignment || 'NONE',
            // Add scheduling fields
            isScheduled: isScheduled || false,
            startDate: isScheduled ? startDate : undefined,
            endDate: isScheduled ? endDate : undefined,
            metadata: {
                header: header || [],
                instructions: instructions || [],
                footer: footer || [],
                watermark: watermark || {}
            },
            sections: sections.map(section => ({
                name: section.name,
                timerEnabled: section.timerEnabled,
                marks: section.marks,
                negativeMarks: section.negativeMarks,
                questions: section.questions,
                isAutogenerated: section.isAutogenerated || false
            }))
        });

        // Save quiz first
        const savedQuiz = await newQuiz.save();

        // Handle batch assignments if specified
        if (batchAssignment === 'SPECIFIC' && Array.isArray(assignedBatches) && assignedBatches.length > 0) {
            await QuizBatch.assignQuizToBatches(
                savedQuiz._id,
                assignedBatches,
                createdBy
            );
        }

        // Update QuestionBank references
        if (sections && sections.length > 0) {
            const questionIds = sections.reduce((acc, section) => {
                return acc.concat(section.questions || []);
            }, []);

            await QuestionBank.updateMany(
                { _id: { $in: questionIds } },
                { $addToSet: { usedInQuizzes: savedQuiz._id } }
            );
        }

        // Fetch the complete quiz with populated data
        const populatedQuiz = await Quiz.findById(savedQuiz._id)
            .populate('createdBy', 'name email')
            .populate({
                path: 'sections.questions',
                model: 'QuestionBank'
            });

        res.status(201).json({
            message: 'Quiz created successfully',
            quiz: {
                ...populatedQuiz.toObject(),
                id: populatedQuiz._id
            }
        });
    } catch (error) {
        console.error('Error creating quiz:', error);
        res.status(500).json({ 
            message: 'Failed to create quiz',
            error: error.message 
        });
    }
};

const getQuizzes = async (req, res) => {
    try {
        const quizzes = await Quiz.find()
            .sort({ createdAt: -1 })
            .populate('createdBy', 'name email')
            .populate({
                path: 'sections.questions',
                model: 'QuestionBank'  // Use QuestionBank model instead of Question
            });
        
        // Add id field for frontend compatibility
        const transformedQuizzes = quizzes.map(quiz => {
            const quizObj = quiz.toObject();
            quizObj.id = quizObj._id;
            
            // Transform sections and questions
            if (quizObj.sections) {
                quizObj.sections = quizObj.sections.map(section => {
                    return {
                        ...section,
                        id: section._id
                    };
                });
            }
            
            return quizObj;
        });
        
        res.status(200).json({
            message: 'Quizzes fetched successfully',
            quizzes: transformedQuizzes
        });
    } catch (error) {
        console.error('Error fetching quizzes:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quizzes',
            error: error.message 
        });
    }
};

const getQuiz = async (req, res) => {
    try {
        const quiz = await Quiz.findById(req.params.id)
            .populate('createdBy', 'name email')
            .populate({
                path: 'sections.questions',
                model: 'QuestionBank'  // Use QuestionBank model instead of Question
            });
        
        if (!quiz) {
            return res.status(404).json({ 
                message: 'Quiz not found' 
            });
        }

        // Add id field for frontend compatibility
        const quizObj = quiz.toObject();
        quizObj.id = quizObj._id;
        
        // Transform sections and questions
        if (quizObj.sections) {
            quizObj.sections = quizObj.sections.map(section => {
                return {
                    ...section,
                    id: section._id
                };
            });
        }

        res.status(200).json({
            message: 'Quiz fetched successfully',
            quiz: quizObj
        });
    } catch (error) {
        console.error('Error fetching quiz:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quiz',
            error: error.message 
        });
    }
};

const updateQuiz = async (req, res) => {
    try {
        const { id } = req.params;
        const updateData = req.body;

        // Handle scheduling data specifically if needed
        if (updateData.isScheduled === false) {
            updateData.startDate = undefined;
            updateData.endDate = undefined;
        }

        const updatedQuiz = await Quiz.findByIdAndUpdate(
            id,
            updateData,
            { new: true, runValidators: true }
        ).populate('createdBy', 'name email');

        if (!updatedQuiz) {
            return res.status(404).json({ 
                message: 'Quiz not found' 
            });
        }

        res.status(200).json({
            message: 'Quiz updated successfully',
            quiz: updatedQuiz
        });
    } catch (error) {
        console.error('Error updating quiz:', error);
        res.status(500).json({ 
            message: 'Failed to update quiz',
            error: error.message 
        });
    }
};

const deleteQuiz = async (req, res) => {
    try {
        const { id } = req.params;
        const userId = req.user._id; // Get the authenticated user's ID

        // Find the quiz and check ownership
        const quiz = await Quiz.findOne({ _id: id, createdBy: userId });
        
        if (!quiz) {
            return res.status(404).json({ 
                message: 'Quiz not found or you do not have permission to delete it' 
            });
        }
        
        // Remove quiz reference from all questions
        await QuestionBank.updateMany(
            { usedInQuizzes: quiz._id },
            { $pull: { usedInQuizzes: quiz._id } }
        );
        
        // Delete all quiz attempts
        await QuizAttempt.deleteMany({ quiz: id });
        
        // Delete the quiz
        const deletedQuiz = await Quiz.findByIdAndDelete(id);

        res.status(200).json({
            message: 'Quiz and related data deleted successfully',
            quiz: deletedQuiz
        });
    } catch (error) {
        console.error('Error deleting quiz:', error);
        res.status(500).json({ 
            message: 'Failed to delete quiz',
            error: error.message 
        });
    }
};

const submitQuizAttempt = async (req, res) => {
console.log('Received request:', req.body);

    try {
        const { id: quizId } = req.params;
        // Get userId from request body if not available in req.user
        const userId = req.user?._id || req.body.userId;
        
        if (!userId) {
            return res.status(400).json({
                message: 'User ID is required. Please provide it in the request body if not authenticated.'
            });
        }
        
        const { answers, timeSpent, completed } = req.body;

        // Validate quiz exists
        const quiz = await Quiz.findById(quizId)
            .populate({
                path: 'sections.questions',
                model: 'QuestionBank'
            });

        if (!quiz) {
            return res.status(404).json({
                message: 'Quiz not found'
            });
        }

        // Calculate score and statistics
        let score = 0;
        let maxScore = 0;
        let correctAnswers = 0;
        let incorrectAnswers = 0;
        let unattemptedAnswers = 0;
        
        // Process each question to calculate score
        quiz.sections.forEach(section => {
            section.questions.forEach(question => {
                const questionId = question._id.toString();
                const userAnswers = answers[questionId] || [];
                // Fix: Use correct_answer instead of correct_answers
                const correctAnswer = question.correct_answer;
                
                // Calculate max possible score for this question
                const questionScore = question.score || section.marks || 1;
                maxScore += questionScore;
                
                // Check if answer is correct (compare single answers)
                const isCorrect = userAnswers.length === 1 && userAnswers[0] === correctAnswer;
                
                if (userAnswers.length === 0) {
                    // Question not attempted
                    unattemptedAnswers++;
                } else if (isCorrect) {
                    // Correct answer
                    score += questionScore;
                    correctAnswers++;
                } else {
                    // Incorrect answer
                    const negativeMarks = question.negative_mark || section.negativeMarks || 0;
                    score -= negativeMarks;
                    incorrectAnswers++;
                }
            });
        });

        // Create new attempt
        const newAttempt = new QuizAttempt({
            quiz: quizId,
            user: userId,
            answers: Object.fromEntries(
                Object.entries(answers).map(([key, value]) => [key, value])
            ),
            score,
            maxScore,
            timeSpent,
            completed,
            correctAnswers,
            incorrectAnswers,
            unattemptedAnswers
        });

        // Save to database
        const savedAttempt = await newAttempt.save();
        
        res.status(201).json({
            message: 'Quiz attempt submitted successfully',
            id: savedAttempt._id,
            attempt: savedAttempt
        });

    } catch (error) {
        console.error('Error submitting quiz attempt:', error);
        res.status(500).json({ 
            message: 'Failed to submit quiz attempt',
            error: error.message 
        });
    }
};

const getAllQuizAttempts = async (req, res) => {
    try {
        const { id: quizId } = req.params;
        
        // Validate quiz exists
        const quiz = await Quiz.findById(quizId);
        if (!quiz) {
            return res.status(404).json({
                message: 'Quiz not found'
            });
        }
        
        // Get all attempts for this quiz
        const attempts = await QuizAttempt.find({ quiz: quizId })
            .populate('user', 'name email')
            .sort({ submittedAt: -1 });
        
        res.status(200).json({
            message: 'Quiz attempts fetched successfully',
            attempts
        });
    } catch (error) {
        console.error('Error fetching quiz attempts:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quiz attempts',
            error: error.message 
        });
    }
};

const getUserQuizAttempts = async (req, res) => {
    try {
        const { id: quizId } = req.params;
        // Get userId from request body if not available in req.user
        const userId = req.user?._id || req.body.userId;
        
        if (!userId) {
            return res.status(400).json({
                message: 'User ID is required. Please provide it in the request body if not authenticated.'
            });
        }
        
        // Validate quiz exists
        const quiz = await Quiz.findById(quizId);
        if (!quiz) {
            return res.status(404).json({
                message: 'Quiz not found'
            });
        }
        
        // Get all attempts for this quiz by this user
        const attempts = await QuizAttempt.find({ 
            quiz: quizId,
            user: userId
        }).sort({ submittedAt: -1 });
        
        res.status(200).json({
            message: 'User quiz attempts fetched successfully',
            attempts
        });
    } catch (error) {
        console.error('Error fetching user quiz attempts:', error);
        res.status(500).json({ 
            message: 'Failed to fetch user quiz attempts',
            error: error.message 
        });
    }
};

const getQuizAttemptDetails = async (req, res) => {
    try {
        const { id: attemptId } = req.params;
        
        // Get attempt details
        const attempt = await QuizAttempt.findById(attemptId)
            .populate('quiz')
            .populate('user', 'name email');
        
        if (!attempt) {
            return res.status(404).json({
                message: 'Quiz attempt not found'
            });
        }
        
        res.status(200).json({
            message: 'Quiz attempt details fetched successfully',
            attempt
        });
    } catch (error) {
        console.error('Error fetching quiz attempt details:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quiz attempt details',
            error: error.message 
        });
    }
};

// Add these methods to your QuizController.js file

// Add batch assignment methods
const assignQuizToBatches = async (req, res) => {
    try {
        const { id: quizId } = req.params;
        const { batchAssignment, assignedBatches } = req.body;
        
        // Find the quiz using either MongoDB ID or UUID
        const quiz = await Quiz.findOne({ 
            $or: [{ _id: quizId }, { id: quizId }]
        });

        if (!quiz) {
            return res.status(404).json({ message: 'Quiz not found' });
        }
        
        // Update the quiz's batch assignment type
        quiz.batchAssignment = batchAssignment;
        await quiz.save();
        
        // Handle batch assignments based on type
        if (batchAssignment === 'SPECIFIC' && Array.isArray(assignedBatches)) {
            // Remove existing assignments
            await QuizBatch.deleteMany({ quiz: quiz._id });
            
            // Create new assignments if batches are specified
            if (assignedBatches.length > 0) {
                await QuizBatch.assignQuizToBatches(
                    quiz._id,
                    assignedBatches,
                    req.user?._id
                );
            }
        } else {
            // Remove all specific assignments for NONE or ALL
            await QuizBatch.deleteMany({ quiz: quiz._id });
        }
        
        // Get updated assignments for response
        const updatedAssignments = batchAssignment === 'SPECIFIC' 
            ? await QuizBatch.find({ quiz: quiz._id })
                .populate('batch', 'name')
            : [];
        
        res.json({ 
            message: 'Quiz batch assignments updated successfully',
            batchAssignment,
            assignedBatches: updatedAssignments.map(a => ({
                id: a.batch._id,
                name: a.batch.name
            }))
        });
    } catch (error) {
        console.error('Error assigning quiz to batches:', error);
        res.status(500).json({ message: 'Failed to assign quiz to batches' });
    }
};

const getQuizBatches = async (req, res) => {
    try {
        const { id: quizId } = req.params;
        
        
        // Find the quiz
        const quiz = await Quiz.findOne({ _id: quizId });
        if (!quiz) {
            return res.status(404).json({ message: 'Quiz not found' });
        }
        
        // Get batch assignment type
        const batchAssignment = quiz.batchAssignment || 'NONE';
        
        // If specific batches, get the assigned batches
        let assignedBatches = [];
        if (batchAssignment === 'SPECIFIC') {
            const assignments = await mongoose.model('QuizBatch')
                .find({ quiz: quiz._id })
                .populate('batch');
            
            assignedBatches = assignments.map(a => a.batch._id.toString());
        }
        
        res.json({
            batchAssignment,
            assignedBatches
        });
    } catch (error) {
        console.error('Error fetching quiz batches:', error);
        res.status(500).json({ message: 'Failed to fetch quiz batches' });
    }
};

// Add new controller method
const updateQuestionUsage = async (req, res) => {
  try {
    const { quizId, questionIds } = req.body;
    
    // Find by MongoDB ID first, then fallback to UUID
    const quiz = await Quiz.findOne({ 
      $or: [{ _id: quizId }, { id: quizId }]
    });
    
    if (!quiz) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }
    
    // Use the MongoDB _id for relationship
    const result = await QuestionBank.updateMany(
      { id: { $in: questionIds } },
      { $addToSet: { usedInQuizzes: quiz._id } }
    );

    res.status(200).json({
      success: true,
      message: `Updated quiz usage for ${result.modifiedCount} questions`
    });
  } catch (error) {
    console.error('Error updating question usage:', error);
    res.status(500).json({
      success: false,
      message: 'Error updating question usage',
      error: error.message
    });
  }
};

// Add this method to your QuizController
const getDetailedQuizReport = async (req, res) => {
    try {
      const quizId = req.params.id;
      const userId = req.user._id;
  
      // Get the quiz
      const quiz = await Quiz.findById(quizId).populate({
        path: 'sections.questions',
        model: 'QuestionBank'
      });
  
      if (!quiz) {
        return res.status(404).json({ message: 'Quiz not found' });
      }
  
      // Get the user's most recent attempt
      const attempts = await QuizAttempt.find({ quiz: quizId, user: userId })
        .sort({ submittedAt: -1 });
  
      if (!attempts || attempts.length === 0) {
        return res.status(404).json({ message: 'No attempts found for this quiz' });
      }
  
      const attempt = attempts[0];
  
      // Extract all questions from the quiz
      const allQuestions = [];
      quiz.sections.forEach(section => {
        section.questions.forEach(question => {
          allQuestions.push(question);
        });
      });
  
      // Calculate overall performance
      const totalQuestions = allQuestions.length;
      const userAnswers = attempt.answers;
      
      let correctAnswers = 0;
      let incorrectAnswers = 0;
      let unattempted = 0;
      let score = 0;
      let maxScore = 0;
  
      // Group questions by different categories
      const subjectMap = new Map();
      const chapterMap = new Map();
      const topicMap = new Map();
      const difficultyMap = new Map();
      const questionTypeMap = new Map();
  
      allQuestions.forEach(question => {
        const questionId = question._id.toString();
        const userAnswer = userAnswers.get(questionId) || [];
        const isCorrect = userAnswer.length > 0 && userAnswer.join(',') === question.correct_answer;
        const isAttempted = userAnswer.length > 0;
        
        // Calculate marks based on section configuration
        const section = quiz.sections.find(s => 
          s.questions.some(q => q._id.toString() === questionId)
        );
        
        const marks = section?.marks || 1;
        const negativeMarks = section?.negativeMarks || 0;
        
        maxScore += marks;
        
        if (isCorrect) {
          correctAnswers++;
          score += marks;
        } else if (isAttempted) {
          incorrectAnswers++;
          score -= negativeMarks;
        } else {
          unattempted++;
        }
  
        // Group by subject
        const subject = question.tags.subject || 'Uncategorized';
        if (!subjectMap.has(subject)) {
          subjectMap.set(subject, {
            subject,
            totalQuestions: 0,
            correctAnswers: 0,
            incorrectAnswers: 0,
            unattempted: 0,
            score: 0,
            maxScore: 0
          });
        }
        const subjectData = subjectMap.get(subject);
        subjectData.totalQuestions++;
        subjectData.maxScore += marks;
        if (isCorrect) {
          subjectData.correctAnswers++;
          subjectData.score += marks;
        } else if (isAttempted) {
          subjectData.incorrectAnswers++;
          subjectData.score -= negativeMarks;
        } else {
          subjectData.unattempted++;
        }
  
        // Group by chapter
        const chapter = question.tags.chapter || 'Uncategorized';
        const chapterKey = `${subject}:${chapter}`;
        if (!chapterMap.has(chapterKey)) {
          chapterMap.set(chapterKey, {
            chapter,
            subject,
            totalQuestions: 0,
            correctAnswers: 0,
            incorrectAnswers: 0,
            unattempted: 0,
            score: 0,
            maxScore: 0
          });
        }
        const chapterData = chapterMap.get(chapterKey);
        chapterData.totalQuestions++;
        chapterData.maxScore += marks;
        if (isCorrect) {
          chapterData.correctAnswers++;
          chapterData.score += marks;
        } else if (isAttempted) {
          chapterData.incorrectAnswers++;
          chapterData.score -= negativeMarks;
        } else {
          chapterData.unattempted++;
        }
  
        // Group by topic
        const topic = question.tags.topic || 'Uncategorized';
        const topicKey = `${subject}:${chapter}:${topic}`;
        if (!topicMap.has(topicKey)) {
          topicMap.set(topicKey, {
            topic,
            chapter,
            subject,
            totalQuestions: 0,
            correctAnswers: 0,
            incorrectAnswers: 0,
            unattempted: 0,
            score: 0,
            maxScore: 0
          });
        }
        const topicData = topicMap.get(topicKey);
        topicData.totalQuestions++;
        topicData.maxScore += marks;
        if (isCorrect) {
          topicData.correctAnswers++;
          topicData.score += marks;
        } else if (isAttempted) {
          topicData.incorrectAnswers++;
          topicData.score -= negativeMarks;
        } else {
          topicData.unattempted++;
        }
  
        // Group by difficulty
        const difficulty = question.tags.difficulty_level || 'Uncategorized';
        if (!difficultyMap.has(difficulty)) {
          difficultyMap.set(difficulty, {
            difficulty,
            totalQuestions: 0,
            correctAnswers: 0,
            incorrectAnswers: 0,
            unattempted: 0,
            score: 0,
            maxScore: 0
          });
        }
        const difficultyData = difficultyMap.get(difficulty);
        difficultyData.totalQuestions++;
        difficultyData.maxScore += marks;
        if (isCorrect) {
          difficultyData.correctAnswers++;
          difficultyData.score += marks;
        } else if (isAttempted) {
          difficultyData.incorrectAnswers++;
          difficultyData.score -= negativeMarks;
        } else {
          difficultyData.unattempted++;
        }
  
        // Group by question type
        const questionType = question.tags.question_type || 'Uncategorized';
        if (!questionTypeMap.has(questionType)) {
          questionTypeMap.set(questionType, {
            questionType,
            totalQuestions: 0,
            correctAnswers: 0,
            incorrectAnswers: 0,
            unattempted: 0,
            score: 0,
            maxScore: 0
          });
        }
        const questionTypeData = questionTypeMap.get(questionType);
        questionTypeData.totalQuestions++;
        questionTypeData.maxScore += marks;
        if (isCorrect) {
          questionTypeData.correctAnswers++;
          questionTypeData.score += marks;
        } else if (isAttempted) {
          questionTypeData.incorrectAnswers++;
          questionTypeData.score -= negativeMarks;
        } else {
          questionTypeData.unattempted++;
        }
      });
  
      // Calculate percentages for each category
      const subjectPerformance = Array.from(subjectMap.values()).map(subject => ({
        ...subject,
        percentage: (subject.score / subject.maxScore) * 100 || 0
      }));
  
      const chapterPerformance = Array.from(chapterMap.values()).map(chapter => ({
        ...chapter,
        percentage: (chapter.score / chapter.maxScore) * 100 || 0
      }));
  
      const topicPerformance = Array.from(topicMap.values()).map(topic => ({
        ...topic,
        percentage: (topic.score / topic.maxScore) * 100 || 0
      }));
  
      const difficultyPerformance = Array.from(difficultyMap.values()).map(difficulty => ({
        ...difficulty,
        percentage: (difficulty.score / difficulty.maxScore) * 100 || 0
      }));
  
      const questionTypePerformance = Array.from(questionTypeMap.values()).map(questionType => ({
        ...questionType,
        percentage: (questionType.score / questionType.maxScore) * 100 || 0
      }));
  
      // Prepare the detailed report
      const detailedReport = {
        overallPerformance: {
          totalQuestions,
          correctAnswers,
          incorrectAnswers,
          unattempted,
          score,
          maxScore,
          percentage: (score / maxScore) * 100 || 0,
          timeSpent: attempt.timeSpent || 0
        },
        subjectWisePerformance: subjectPerformance,
        chapterWisePerformance: chapterPerformance,
        topicWisePerformance: topicPerformance,
        difficultyWisePerformance: difficultyPerformance,
        questionTypePerformance: questionTypePerformance
      };
  
      res.status(200).json({
        message: 'Detailed quiz report fetched successfully',
        report: detailedReport,
        attemptId: attempt._id
      });
    } catch (error) {
      console.error('Error generating detailed quiz report:', error);
      res.status(500).json({
        message: 'Failed to generate detailed quiz report',
        error: error.message
      });
    }
  };

// Export the new methods
export default {
    createQuiz,
    getQuizzes,
    getQuiz,
    updateQuiz,
    deleteQuiz,
    submitQuizAttempt,
    getAllQuizAttempts,
    getUserQuizAttempts,
    getQuizAttemptDetails,
    getDetailedQuizReport,
    assignQuizToBatches,
    getQuizBatches,
    updateQuestionUsage
};
