import Quiz from '../models/Quiz.js';
import QuizAttempt from '../models/QuizAttempt.js';
import { v4 as uuidv4 } from 'uuid'; // Add this import at the top
import QuestionBank from '../models/QuestionBank.js';

const createQuiz = async (req, res) => {
    try {
        const { 
            title,
            description,
            total_duration,
            passingScore,
            header,
            instructions,
            footer,
            watermark,
            sections,
            createdBy
        } = req.body;

        // Create new quiz with unique ID
        const newQuiz = new Quiz({
            id: uuidv4(), // Generate unique ID
            title,
            description,
            total_duration: total_duration || 0,
            timeLimit: total_duration || 0,
            passingScore: passingScore || 70,
            createdBy,
            metadata: {
                header: header || [],
                instructions: instructions || [],
                footer: footer || [],
                watermark: watermark || {}
            },
            sections: sections.map(section => ({
                name: section.name,
                timerEnabled: section.timerEnabled,
                marks: section.marks,
                negativeMarks: section.negativeMarks,
                questions: section.questions,
                isAutogenerated: section.isAutogenerated || false
            }))
        });

        // Save to database
        const savedQuiz = await newQuiz.save();
        
        // Update QuestionBank documents to include this quiz in usedInQuizzes
        if (sections && sections.length > 0) {
            const questionIds = sections.reduce((acc, section) => {
                return acc.concat(section.questions || []);
            }, []);

            await QuestionBank.updateMany(
                { _id: { $in: questionIds } },
                { $addToSet: { usedInQuizzes: savedQuiz._id } }
            );
        }
        
        res.status(201).json({
            message: 'Quiz created successfully',
            quiz: savedQuiz
        });
    } catch (error) {
        console.error('Error creating quiz:', error);
        res.status(500).json({ 
            message: 'Failed to create quiz',
            error: error.message 
        });
    }
};

const getQuizzes = async (req, res) => {
    try {
        const quizzes = await Quiz.find()
            .sort({ createdAt: -1 })
            .populate('createdBy', 'name email')
            .populate({
                path: 'sections.questions',
                model: 'QuestionBank'  // Use QuestionBank model instead of Question
            });
        
        // Add id field for frontend compatibility
        const transformedQuizzes = quizzes.map(quiz => {
            const quizObj = quiz.toObject();
            quizObj.id = quizObj._id;
            
            // Transform sections and questions
            if (quizObj.sections) {
                quizObj.sections = quizObj.sections.map(section => {
                    return {
                        ...section,
                        id: section._id
                    };
                });
            }
            
            return quizObj;
        });
        
        res.status(200).json({
            message: 'Quizzes fetched successfully',
            quizzes: transformedQuizzes
        });
    } catch (error) {
        console.error('Error fetching quizzes:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quizzes',
            error: error.message 
        });
    }
};

const getQuiz = async (req, res) => {
    try {
        const quiz = await Quiz.findById(req.params.id)
            .populate('createdBy', 'name email')
            .populate({
                path: 'sections.questions',
                model: 'QuestionBank'  // Use QuestionBank model instead of Question
            });
        
        if (!quiz) {
            return res.status(404).json({ 
                message: 'Quiz not found' 
            });
        }

        // Add id field for frontend compatibility
        const quizObj = quiz.toObject();
        quizObj.id = quizObj._id;
        
        // Transform sections and questions
        if (quizObj.sections) {
            quizObj.sections = quizObj.sections.map(section => {
                return {
                    ...section,
                    id: section._id
                };
            });
        }

        res.status(200).json({
            message: 'Quiz fetched successfully',
            quiz: quizObj
        });
    } catch (error) {
        console.error('Error fetching quiz:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quiz',
            error: error.message 
        });
    }
};

const updateQuiz = async (req, res) => {
    try {
        const { id } = req.params;
        const updateData = req.body;

        const updatedQuiz = await Quiz.findByIdAndUpdate(
            id,
            updateData,
            { new: true, runValidators: true }
        ).populate('createdBy', 'name email');

        if (!updatedQuiz) {
            return res.status(404).json({ 
                message: 'Quiz not found' 
            });
        }

        res.status(200).json({
            message: 'Quiz updated successfully',
            quiz: updatedQuiz
        });
    } catch (error) {
        console.error('Error updating quiz:', error);
        res.status(500).json({ 
            message: 'Failed to update quiz',
            error: error.message 
        });
    }
};

const deleteQuiz = async (req, res) => {
    try {
        const { id } = req.params;
        const userId = req.user._id; // Get the authenticated user's ID

        // Find the quiz and check ownership
        const quiz = await Quiz.findOne({ _id: id, createdBy: userId });
        
        if (!quiz) {
            return res.status(404).json({ 
                message: 'Quiz not found or you do not have permission to delete it' 
            });
        }
        
        // Remove quiz reference from all questions
        await QuestionBank.updateMany(
            { usedInQuizzes: quiz._id },
            { $pull: { usedInQuizzes: quiz._id } }
        );
        
        // Delete all quiz attempts
        await QuizAttempt.deleteMany({ quiz: id });
        
        // Delete the quiz
        const deletedQuiz = await Quiz.findByIdAndDelete(id);

        res.status(200).json({
            message: 'Quiz and related data deleted successfully',
            quiz: deletedQuiz
        });
    } catch (error) {
        console.error('Error deleting quiz:', error);
        res.status(500).json({ 
            message: 'Failed to delete quiz',
            error: error.message 
        });
    }
};

const submitQuizAttempt = async (req, res) => {
console.log('Received request:', req.body);

    try {
        const { id: quizId } = req.params;
        // Get userId from request body if not available in req.user
        const userId = req.user?._id || req.body.userId;
        
        if (!userId) {
            return res.status(400).json({
                message: 'User ID is required. Please provide it in the request body if not authenticated.'
            });
        }
        
        const { answers, timeSpent, completed } = req.body;

        // Validate quiz exists
        const quiz = await Quiz.findById(quizId)
            .populate({
                path: 'sections.questions',
                model: 'QuestionBank'
            });

        if (!quiz) {
            return res.status(404).json({
                message: 'Quiz not found'
            });
        }

        // Calculate score and statistics
        let score = 0;
        let maxScore = 0;
        let correctAnswers = 0;
        let incorrectAnswers = 0;
        let unattemptedAnswers = 0;
        
        // Process each question to calculate score
        quiz.sections.forEach(section => {
            section.questions.forEach(question => {
                const questionId = question._id.toString();
                const userAnswers = answers[questionId] || [];
                // Fix: Use correct_answer instead of correct_answers
                const correctAnswer = question.correct_answer;
                
                // Calculate max possible score for this question
                const questionScore = question.score || section.marks || 1;
                maxScore += questionScore;
                
                // Check if answer is correct (compare single answers)
                const isCorrect = userAnswers.length === 1 && userAnswers[0] === correctAnswer;
                
                if (userAnswers.length === 0) {
                    // Question not attempted
                    unattemptedAnswers++;
                } else if (isCorrect) {
                    // Correct answer
                    score += questionScore;
                    correctAnswers++;
                } else {
                    // Incorrect answer
                    const negativeMarks = question.negative_mark || section.negativeMarks || 0;
                    score -= negativeMarks;
                    incorrectAnswers++;
                }
            });
        });

        // Create new attempt
        const newAttempt = new QuizAttempt({
            quiz: quizId,
            user: userId,
            answers: Object.fromEntries(
                Object.entries(answers).map(([key, value]) => [key, value])
            ),
            score,
            maxScore,
            timeSpent,
            completed,
            correctAnswers,
            incorrectAnswers,
            unattemptedAnswers
        });

        // Save to database
        const savedAttempt = await newAttempt.save();
        
        res.status(201).json({
            message: 'Quiz attempt submitted successfully',
            id: savedAttempt._id,
            attempt: savedAttempt
        });

    } catch (error) {
        console.error('Error submitting quiz attempt:', error);
        res.status(500).json({ 
            message: 'Failed to submit quiz attempt',
            error: error.message 
        });
    }
};

const getAllQuizAttempts = async (req, res) => {
    try {
        const { id: quizId } = req.params;
        
        // Validate quiz exists
        const quiz = await Quiz.findById(quizId);
        if (!quiz) {
            return res.status(404).json({
                message: 'Quiz not found'
            });
        }
        
        // Get all attempts for this quiz
        const attempts = await QuizAttempt.find({ quiz: quizId })
            .populate('user', 'name email')
            .sort({ submittedAt: -1 });
        
        res.status(200).json({
            message: 'Quiz attempts fetched successfully',
            attempts
        });
    } catch (error) {
        console.error('Error fetching quiz attempts:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quiz attempts',
            error: error.message 
        });
    }
};

const getUserQuizAttempts = async (req, res) => {
    try {
        const { id: quizId } = req.params;
        // Get userId from request body if not available in req.user
        const userId = req.user?._id || req.body.userId;
        
        if (!userId) {
            return res.status(400).json({
                message: 'User ID is required. Please provide it in the request body if not authenticated.'
            });
        }
        
        // Validate quiz exists
        const quiz = await Quiz.findById(quizId);
        if (!quiz) {
            return res.status(404).json({
                message: 'Quiz not found'
            });
        }
        
        // Get all attempts for this quiz by this user
        const attempts = await QuizAttempt.find({ 
            quiz: quizId,
            user: userId
        }).sort({ submittedAt: -1 });
        
        res.status(200).json({
            message: 'User quiz attempts fetched successfully',
            attempts
        });
    } catch (error) {
        console.error('Error fetching user quiz attempts:', error);
        res.status(500).json({ 
            message: 'Failed to fetch user quiz attempts',
            error: error.message 
        });
    }
};

const getQuizAttemptDetails = async (req, res) => {
    try {
        const { id: attemptId } = req.params;
        
        // Get attempt details
        const attempt = await QuizAttempt.findById(attemptId)
            .populate('quiz')
            .populate('user', 'name email');
        
        if (!attempt) {
            return res.status(404).json({
                message: 'Quiz attempt not found'
            });
        }
        
        res.status(200).json({
            message: 'Quiz attempt details fetched successfully',
            attempt
        });
    } catch (error) {
        console.error('Error fetching quiz attempt details:', error);
        res.status(500).json({ 
            message: 'Failed to fetch quiz attempt details',
            error: error.message 
        });
    }
};

// Add these methods to the export
export default {
    createQuiz,
    getQuizzes,
    getQuiz,
    updateQuiz,
    deleteQuiz,
    submitQuizAttempt,
    getAllQuizAttempts,
    getUserQuizAttempts,
    getQuizAttemptDetails
};